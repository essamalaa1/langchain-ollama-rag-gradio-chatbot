LangChain has evolved since its initial release, and many of the original "Chain" classes
have been deprecated in favor of the more flexible and powerful frameworks of LCEL and LangGraph.

This guide will help you migrate your existing v0.0 chains to the new abstractions.

Even though many of these implementations are deprecated, they are still supported in the codebase.
However, they are not recommended for new development, and we recommend re-implementing them using the following guides!

To see the planned removal version for each deprecated implementation, check their API reference.

These guides assume some familiarity with the following concepts:

LangChain Expression Language

LangGraph

LangChain maintains a number of legacy abstractions. Many of these can be reimplemented via short combinations of LCEL and LangGraph primitives.

LCEL

LCEL is designed to streamline the process of building useful apps with LLMs and combining related components. It does this by providing:

A unified interface : Every LCEL object implements the Runnable interface, which defines a common set of invocation methods ( invoke , batch , stream , ainvoke , ...). This makes it possible to also automatically and consistently support useful operations like streaming of intermediate steps and batching, since every chain composed of LCEL objects is itself an LCEL object.

Runnable

invoke

batch

stream

ainvoke

Composition primitives : LCEL provides a number of primitives that make it easy to compose chains, parallelize components, add fallbacks, dynamically configure chain internals, and more.

LangGraph

LangGraph , built on top of LCEL, allows for performant orchestrations of application components while maintaining concise and readable code. It includes built-in persistence, support for cycles, and prioritizes controllability.
If LCEL grows unwieldy for larger or more complex chains, they may benefit from a LangGraph implementation.

Advantages

Using these frameworks for existing v0.0 chains confers some advantages:

The resulting chains typically implement the full Runnable interface, including streaming and asynchronous support where appropriate;

Runnable

The chains may be more easily extended or modified;

The parameters of the chain are typically surfaced for easier customization (e.g., prompts) over previous versions, which tended to be subclasses and had opaque parameters and internals.

If using LangGraph, the chain supports built-in persistence, allowing for conversational experiences via a "memory" of the chat history.

If using LangGraph, the steps of the chain can be streamed, allowing for greater control and customizability.

The below pages assist with migration from various specific chains to LCEL and LangGraph:

LLMChain

ConversationChain

RetrievalQA

ConversationalRetrievalChain

StuffDocumentsChain

MapReduceDocumentsChain

MapRerankDocumentsChain

RefineDocumentsChain

LLMRouterChain

MultiPromptChain

LLMMathChain

ConstitutionalChain

Check out the LCEL conceptual docs and LangGraph docs for more background information.

Was this page helpful?

LCEL

LangGraph

Advantages